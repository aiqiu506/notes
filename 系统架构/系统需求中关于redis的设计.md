设计原则：1、规范命名  2、优化查询

`  多级key时，采用` _` 进行分隔，采用'名称+类型'方式`





#### 雇主需求信息key

>  类型：hash

###### 命名规则： mission_info_hrId_hash  【名称\_hr表中id\_类型】

###### 作用：用于记录当前需求的状态相关信息

格式：

```json
 mission_info_hrId_hash:{
    status: "2",//当前状态,待匹配、待开工、工作中、待审核、待结算、已完成
    noder_no:"2019042312312312313",//订单号
    need_num:2 ,//需求人数
    match_num:1, //已匹配人数
    worked_num:1,  //完成工作人数(决定收多少人的服务费，审核成功时更新)
    should_money:20.32,//预付金额
    should_fee:3,//预付服务费
    payed_money:10.32,//实付金额
    payed_fee: 4,//实付服务费
     ……
    name:"任务名称"，
    work_date:["开始日期","结束日期"]//用数组，以防需求变更为跨天
    work_time:[{"time_s"："开始时间","time_e":"结束时间"}，{"time_s"："开始时间","time_e":"结束时间"}] //元素的个数，决定时间段的个数。主要用于显示


    pending_num:0//当将状态，待处理人数，(表示某状态下，剩余需处理人数)
}
```



#### 某雇主需求匹配列表Key

>  类型：zset 
>

###### 命名规则： mission_match_hrId_zset 

###### 作用：用于记录某任务的匹配情况，在雇员抢单后生成，子订单状态改变时更新。

格式：

```json
mission_match_hrId_zset:{
    hrContractid:"1000"//表示已经匹配的子任务的id：
}
```

采用zset的格式，一是为用于限制，同一个用户，只能匹配一次。其次，用于标识当前已经匹配子任务的状态

score的规则为：

```    
	
	1：雇员取消
	
 	2：雇主解聘

    3: 雇主终止

    4：正常工作中

    5：待审核

    6：已经完成

	……

```

​       

可以通过该key的members，获取已经匹配的雇员，同时可以快速按状态获取子订单【用于获取不同状态的主订单下的子订单】



####  雇员订单打卡记录key

>  类型：hash 
###### 命名规则： misson_punch_hrContractid_hash
###### 作用：用于记录某雇员的订单的打卡情况
```json
misson_punch_hrContractid_hash:{
    status:-1,
    //当前打卡待处理状态 -1:已完成（已经拿到钱了），0：提前下班， 1：待上班，11：补上班卡，2休息卡，22 补休息卡 3：返工卡，33 补返工卡 4：下班卡，44：补下班卡，
    should_time_时间截：0，//实际打卡时间，[默认为0，表示未打卡]
    should_time_时间截：0，//实际打卡时间，[默认为0，表示未打卡]
    should_time_时间截：0，//实际打卡时间，[默认为0，表示未打卡]
    should_time_时间截：0，//实际打卡时间，[默认为0，表示未打卡]
    
    
    duration:4,//实际工作时长多少个单位时间(一个单位为0.5h，不足部分为0)
    earn_money:实际工资(不含服务费)
    deduct_fee：需扣服务费
    
}
```
通过 hscan misson_punch_hrContractid_hash should_time_*,可以获取所有的应该打卡的字段，以及对应的值(实际打卡时间，或未打卡)。





#### 各key更新场景

1、雇员取消

2、雇主解聘

3、雇主终止

4、打卡

5、补卡（也可以算做是打卡的一种）

6、审核 通过

7、审核不通过

……