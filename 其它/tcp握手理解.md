## TCP的握手理解

```
|--------------------------------------------
  Author:       intro                        
  CreateAt:   2020-04-22 23:13:10          
|--------------------------------------------
  
```

tcp是一种面向连接的协议，支持丢包重传。也就是说客户端与服务端要相互确认后才可以进行数据的传输。断开连接，也是需要客户端与服务端的相互确认。这里不研究 tcp 的传输。只是聊聊连接建立与断开时的握手约定。

####建立连接的三次握手

![image-20200422213352488](/Users/intro/Library/Application Support/typora-user-images/image-20200422213352488.png)

![image-20200422214251740](/Users/intro/Library/Application Support/typora-user-images/image-20200422214251740.png)

（1）建立连接时，客户端发送syn包(syn=X)到服务器，并进入SYN_SEND状态，等待服务器确认；

（2）服务器收到syn包，必须确认客户的SYN（ack=X+1），同时自己也发送一个SYN包（syn=Y），即SYN+ACK包，此时服务器 进入SYN_RECV状态；

（3）客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=Y+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。 

完成三次握手，客户端与服务器开始传送数据。

> 上面两图不一样？

  SYN=x 表示的是，客户端发送一个内容：seq=x  ,seq 是随机生成的一个序列号。为什么是随机，据说是为了安全。 我们把这个包叫 `SYN 包`

SYN+ACK 表示的是，服务端发送一个数据包，内容是：ack=x+1,seq=y 的包。名称叫`SYN+ACK`

> 理解辅助

   第一次：客户端 --- (在吗？我想和你通信)------>  服务端

   第二次：服务端 ------(在的，你还在吗？)--------> 客户端

   第三次： 客户端 -----------（在的）----------------->  服务端



#### 断开连接的四次挥手

![image-20200422215637104](/Users/intro/Library/Application Support/typora-user-images/image-20200422215637104.png)

通过四次挥手来关闭TCP连接：

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。此时 A 进入 `FIN_WAIT1`等待状态

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。服务端进入 `CLOSE_WAIT`状态，客户端接收到 服务端的 ACK后，进入`FIN_WAIT2`等待状态

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。服务端进入`LAST_ACK`状态。客户端收到后，进入 `TIME_WAIT`状态。等待一段时间（2MSL（最长报文段寿命））后，进入`CLOSE`状态

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。服务端进入`CLOSE`状态

> 理解辅助

第一次：  客户端 ---------------（我要挂电话了，可以吗）-------------> 服务端

第三次：  服务端 ----------------------------（可以）--------------------------> 客户端

第三次：  服务端 -------（还能听到吗？我也要挂电话了）------------> 客户端

第四次：  客户端 -------------------------（听到了）--------------------------> 服务端



### 思考： 为什么建立连接是三次握手，断开却要四次握手呢？

首先，建立连接需要三次的原因，是因为对方相互确认对方的状态。从而保证连接的正确建立。

二次握手为什么不能确认对方状态？

如果客户端想建立连接，给服务端发了一个连接请求（SYN），但是由于网络中种种情况，导致没有及时到达服务端，这就导致客户端在很长一段时间中没有收到回复消息（ACK），这时客户端又给服务端发送一个SYN，这次的发送和接收的很顺利，很快就收到了ACK，但是这时之前的SYN终于到了服务端，服务端规规矩矩的为这个SYN申请资源，然后返回ACK。由于之前的SYN已经失效了，所以客户端也不会去理会这个ACK，但是傻乎乎的服务端并不知道这个SYN已经失效了，一直为他委会着资源，这就造成了资源的浪费。

第三次握手就是客户端给服务端回复第二次握手，这也就是说服务端会等第三次握手的到来，如果第三次握手迟迟不来，服务端就可以识别这个SYN是无效的，就会将他的资源释放了。还有一种情况就是第三次握手由于网络中的种种原因失败了，这时候客户端认为自己已经连接好了，就会给服务端发送数据，服务端由于没有收到第三次握手，就会以RST包对客户端响应，收到RST的的客户端就知道第三次握手没有成功，就会重新执行第一次握手。

##### 第一次握手失败：
  如果第一次的SYN传输失败，两端都不会申请资源。如果一段时间后之前的SYN发送成功了，这时客户端只会接收他最后发送的SYN的SYN+ACK回应，其他的一概忽略，服务端也是如此，会将之前多申请的资源释放了。

##### 第二次握手失败：
  如果服务端发送的SYN+ACK传输失败，客户端由于没有收到这条响应，不会申请资源，虽然服务端申请了资源，但是迟迟收不到来自客户端的ACK，也会将该资源释放。

##### 第三次握手失败:
  如果第三次握手的ACK传输失败，导致服务端迟迟没有收到ACK，就会释放资源，这时候客户端认为自己已经连接好了，就会给服务端发送数据，服务端由于没有收到第三次握手，就会以RST包对客户端响应。但是实际上服务端会因为没有收到客户端的ACK多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到客户端的ACK，则释放资源。



断开进需要四次的原因，也是相互确认状态。服务收到 FIN 消息后，先返回一个 ack，相当于告诉客户端，我已经收到了，但我现在还不能断开。服务端确认可以断开的时候，才向客户端发送 FIN 消息。

TCP是全双工模式，接收方接收到FIN意味着没有数据再发来，但是还可以继续发送数据。