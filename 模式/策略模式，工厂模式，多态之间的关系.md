### 策略模式，工厂模式，多态之间的关系

  23种设计模式中的两个设计模式和面向对象的三大特征其中之一的关系。其实是很显然的关系，23种设计模式是基于OOP思想与提取出来的应用。那自然也可以理解为，策略模式和工厂模式是多态的应用。可是真的那么好理解吗？接下来，进行一点点的剖析。

##### 多态

作为面向对象OOP的三大特性之一的多态。是任何一个实现oop的语言所必不可少的。

代码表示为：

```php
   function Hello($obj){
       $obj->sayHello();
   }
   
   class Dog{
       
       public function sayHello(){
             echo "wangwang";
       }
       
   }
   class Cat{
        public function sayHello(){
             echo "miaomiao";
        }
   }
   Hello(new Dog);
   Hello(new Cat);



```
定义了一个a方法，需要一个参数 ，这个参数 有一个sayHello的方法。而两次调用同一个方法，得到不同的结果 ，就是最基本的多态。

个人理解为:`同一个方法，因为传入参数的不同，产生了不同的结果`。



稍微有点经验的人都知道，这段代码是有问题的。如果调用`Hello `方法的时候，传入的参数 ，不具有可调用的`sayHello`方法时，代码就会报错了。所以OOP三大特性中另一个基本特性来了，继承。

##### 继承

继承是父子之间的关系，父类（基类）的非私有属性和方法，可以被子类获取。看一段代码：

~~~php
//定义一个Animal的基类
class Animal{
    public function sayHello(){
        echo "hi";
    }
}

//定义一个cat类，继承Animal
class Cat extends Animal{
    
}
//定义一个Dog类，继承Animal
class Dog extends Animal{
    
}
~~~



如果Dog和Cat都继承至另一个Animal，那么，此时 `Hello`方法里，就可以做一些约束了

```php
function Hello(Animal $obj){}
```

 即在`Hello`参数处，添加`Animal`的类型限制。

问题现在都解决了吗？如果现在的代码一运行，会发现，`sayHello`方法的调用，都输出了两样的“`hi`”，这个不符合实际场景，Dog和Cat，打招呼的方式可是不一样的。 所以，那就把 子类里的都各自加上`sayHello`方法吧。

如果那天People也要一个打招呼的功能，而恰好忘了自己去实现`sayHello` 方法呢？

那就再来一个约定吧。定义，继承者们，都必须实现某个方法，而这个方法在父类中，被称为`抽象方法(abstract)`,只要继承至这个父类，就必须实现这个方法。父类只负责定义方法的样子（名称、参数 ）,具体方法的实现，将交由子类来完成。

这个时候，代码修改为：

```php
abstract class Animal{
    public abstract function sayHello()
}
```

##### 抽象类

  1、包含至少一个抽象方法的类，被称之为抽象类。

`2、抽象类不能被实例化`，也就是不可以被new。而除了抽象方法外，还可以用其它非抽象方法和属性，那这些又将如何被调用呢？没错，作为父类被子类继承，所以作为父类（基类）是抽象类的应用。

刚说到约定。。抽象类只是其中的一种不算太严格的实现，另一种叫做 `接口`的结构，才是彻彻底底的约束。

##### 接口

 接口的定义，就是用来约束两种类型之间的关系的。看一段代码：

```php
interface IAinaml{
    sayHello();
}
```

定义了一个包含`sayHello`的接口类型。上面的代码也可以被改写成：

```php
//定义一个Animal的基类
interface IAinaml{
    sayHello();
}

//定义一个cat类，继承Animal
class Cat implements Animal{
    function sayHello(){
        echo "miaomiao";
    }
}
//定义一个Dog类，继承Animal
class Dog implements Animal{
     function sayHello(){
        echo "wangwang";
    }
}
function Hello(IAnimal $obj){
    $obj->sayHello();
}
```



接口的定义，只能包含一个或多个方法的定义，且这些方法属性只能是`Public`类型。一个接口的实现类，如上面代码中的 Dog类，可以实现多个类，即Dog类不仅可以实现`IAinaml`接口，还可以实现别的接口。只要Dog类中有其它接口所定义的方法。在Dog的定义的`implements`列表中，加上对其它类的类名即可。



上段代码较之前的改动不大，只是将`继承` 的关系换成了`实现`。那么，既然通过父类与子类的继承已经可以实现，且通过接口与实现类也可以实现，那接口的应用场景与抽象类不同之处在哪？

个人理解。由于接口要求，实现者，必须实现其定义的所有的方法，是一种更为严格的类型。通常类型的选择依据是`变化 `，俗话说的好，好的框架设计，一定是拥抱变化的。如果变化的频次比较大，建议使用抽象方法。而不使用接口。接口一但变化，所有的实现者都需要跟着变化。而抽象类中，可以定义为非抽象方法，并且有默认实现。相反，就可以使用接口，如果还不确定，下表中列出了抽象类和接口的比较。

| 抽象类     | 接口 |
| ---------------- | ------------ |
| 它可以有默认的方法实现           | 接口完全是抽象的。它根本不存在方法的实现     |
| 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现       |
| 抽象方法可以有public、protected和修饰符 | 接口方法默认修饰符是public。你不可以使用其它修饰符 |
| 抽象方法可以继承一个类和实现多个接口 | 接口只可以继承一个或多个其它接口 |
| 它比接口速度要快 | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法 |
| 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类 |



ok,到这里已经了解了多态。接下来看看 工厂模式和策略模式

##### 工厂模式

工厂模式是23种设计模式中最基础的模式。23种设计模式按目的可以分为：创建型，结构型，行为型。而工厂模式是属于其中的 创建型。即用于创建一个对象的模式。

与工厂模式相关的，有简单工厂、工厂方法以及抽象工厂。

简单工厂，代码实现：

```php
class A{
    
}
class B{
    
}
//定义最简单的工厂方法用于生产A和B类的对象
function newObj($name){
    if($name=="A"){
        return new A;
    }
    if($name=="B"){
        return new B;
    }
}
$objA=newObj("A");
$objB=newObj("B");
```

上述代码，就是最简单的简单工厂的实现，当然也是问题多多。 比如，我再增加一个C类，也想要通过`newObj`方法来实现时。就得改代码。或是我输入除A和B以外的东西，就产生了异常。

于是乎有人想到了，多个if else 的判断可以改成下面这种方式：

```php
class CreateProduct{
    //生产A产品
    function createProductA(){
         return  new A;
    }
    //生产B产品
    function createProductB(){
        return new B;
    }
}
//创建一个A类的对象
$cp=new CreateProduct();
$cb->createProductA();

```

这个就是所谓的` 工厂方法`。甚至可以将 **createProductA方法定义成static**，从而省去new CreateProduct这一步。

看起来，已经很好了。但是、那如果我现在要生产一个C产品的时候。就必须要改动CreateProduct类。

在面向对象的设计原则里，开-闭原则中明确“`对扩展开放，对修改关闭`”，意思是，新的需求，应该以扩展的方式来写代码，而不是修改原来的代码。

俗话又说"`没有什么问题是加一个中间层解决不了的`"

所以，上述问题，需要加一个中间层，如何加呢？就是`抽象工厂模式`

实现代码为：

```php 
//定义一个工厂抽象类，用于约束各种工厂的行为
abstract class Factory{
    function abstract newObj();
}
//定义一个生产A产品的工厂
class FactoryA extends Factory{
    //实现生产A产品
    function newObj(){
        return new A;
    }
}
//定义一个生产B产品的工厂
class FactoryB extends Factory{
     //实现生产B产品
     function newObj($name){
        return new A;
    }
}
//通过FactoryA工厂来生产$factory的工厂实例，再调用工厂实例的newObj，来生产具体的对象
$factory=new FactoryA();
$objA=$factory->newObj();
$factory=new FactoryB();
$objB=$factory->newObj();
```

通过具体的工厂来生产对应的对象.，如果有新的产品C加入时，只需要增加对应的FactoryC工厂类，由工厂类来生产具体的对象。

这样就符合了`开-闭原则`。但也带来了一系列的复杂度。虽然不直接通过`new A`来产生A类的实例了。但是，却要使用`new FactoryA`出来的对象，进行调用。这难道不是"**脱裤子放屁**"？

回归到工厂模式的本意，为什么要使用工厂？ 通过一个很简单的变量或常量，来创建一个对象。这么做的好处：

>  一、创建与使用分离。把所有new的部分都好到一起，万一类的构造方法发生了改变时，不需要满世界查找所有new的地方。只需要在工厂里进行修改即可。
>
> 二、隐藏对象创建细节。有些对象的创建需要给属性赋默认值，或其它运算。所以都可以在对象创建的工厂里处理，将这些细节对使用者（调用者）而言，是透明的。

到这里，已经完成了工厂模式的理解。接下来再看看策略模式

策略模式定义了一系列算法,并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户端而独立的变化。好难理解的一段话。

个人理解 。策略，即是做一个决策。在大家都提供某种功能时，决定用哪一个类的实例来实现。

是时候和标题“`策略模式，工厂模式，多态之间的关系`”产生点关系了。

再次简单理解一下

**多态**：

> 同一个方法的调用，不同的效果

**策略模式**：

> 不同的调用者，可以调用同一个方法。

**工厂模式**：

> 抽象工厂，所用的抽象类（接口）中约定的某方法来创建对象，扩展类（实现类）中，实现了这个方法，返回一个对象。



个人愚见：**工厂模式，不再产生对象的时候，就是策略模式了。策略模式，决策出到底用哪个工厂类来生产。**

