### 适配器模式是为了解决什么样的问题？

首先，我们需要理解一下什么是适配器模式。最后再来回答这个问题。

我们知道主机可以连接显示器的方式，有HDMI,VGA,DP……

现我们手里，主机只剩下一个HDMI的口可以连接显示器了，而旧一点的显示器只支持VGA接口。那么，我现在有两个方案：

> 一、买一根HDMI的线，再买一个HDMI转VGA的转接头
> 二、买一根VGA的线，再买一个VGA转HDMI的转接头

不管是哪种线，都需要再买一个转接头。

考虑到旧显示器会比较快淘汰，所以，通常的做法会选择方案一。

适配器就相当于那个转接头。而适配器模式就是为了解决：`希望复用一些类(旧显示器)，但是接口（主机的显卡连接头）又与复用环境的要求(显示器连接头)不一致`  。  出现了这种不匹配的问题  ，通过适配器这个中间层，可以得到很好的解决。

适配器模式简单来说就是：`多个不确定的输入 ------> 适配器 ————>确定的输出`

如果还是不太理解，可以再举个例子。

> 修一座大桥，往往是城市规划局而言，就是修一整座3千米的桥【确定的输出】，而对于有些修桥公司而言，只能一段一段地修，一段50米，有些能一段修80米【不确定的输入】。
>
> 那么对于城市规划局的要求，修桥公司是不能满足的，出现了**不匹配**。
>
> 一个承包商【适配器】听到了对城市规划局说，修一座3千米的桥，没问题的，交给我好了，到你手上的一定是一座3千米的大桥。

实际生活中的例子是数不胜数了。那放在我们的项目工程中。是什么样的场景，以及如何实现的？

### 怎么实现的？

我们把上面举的修桥的例子程序抽象化：

~~~php
<?php
//定义接口，确定修的是3千米的大桥。即[确定的输出]
interface Target{
  public function make3KilBrige();
}  
  
  
//定义 修桥公司，能修50米一段的桥段。 即[不确定的输入]
class BrigeCompany {
   public function make50mBrigePart(){
     echo "修50米";
   }
}
//定义 承包商 ，将50米转化成3千米。 即[适配器]  
class AdapterCompany extends BrigeCompany implements Target  {
  //实现修3千米大桥
   public function make3KilBrige(){
       foreach ($i=0;$i<60;$i++){
         parent::make50mBrigePart();
       }
   }
}
// 城市规划局(使用者)
class CityCreater {
  private $adapterCompany;
  public function __construct(AdapterCompany $a){
    $this->adapterCompany=$a;
  }
   public function makeBrige(){
      $this->adapterCompany->make3KilBrige();
   }
}

$cityCreater=new CityCreater(new AdapterCompany);
$cityCreater->makeBrige();

~~~



还有一种理解：类或接口A与类B，和配置器C，配置器C中与A类同名F方法【实现或继承】的调用，但内容却是调用的B类的某一个类似功能F1方法来实现。



关于适配器的实现，并非只有上面这一种方式。从上面代码来看，虽然暂时实现了需求，但如果后期需要加入 从成本的角度，对不同修桥公司的修桥造价进行投标。所以我们需要对多个不同的修桥公司进行适配。

我们先了解一下 适配器模式的几种分类(类适配器、对象适配器、接口适配器):

#### 类适配器

 实现采用继承的方式，即 上述例子的实现代码的方式。

php或是java都是只能继承一个类，所以适配器先继承 【不确定的输入】，然后实现 【确定的输出】。因为单一继承的原故，所以 【确定的输出】只能定义成接口类型。事实是，接口如果能换成抽象类，将能做更多的事。

类的适配器方式，局限性很大。所以，有了下面的对象适配器的方式。



#### 对象适配器

大致和类适配器相似，只是不同之处在于原本 `适配器先继承 【不确定的输入】`，修改为，对`【不确定的输入】`的实例的依赖。

```php
<?php 
class AdapterCompany implements Target  {
  private $make50m;
  public function __contruct(BrigeCompany $b){
    $this->make50m=$b;
  }
  //实现修3千米大桥
   public function make3KilBrige(){
       foreach ($i=0;$i<60;$i++){
         $this->make50m->make50mBrigePart();
       }
   }
}
```

粗看，好像没有太大的改变。其实不然，在new AdapterCompany时，输入一个BrigeCompany 类型的实例为参数。

如果再将BrigeCompany 定义为接口的话，就能传入不同的实现类的实例。

#### 接口适配器

接口适配器的概念与上两种有所区别。

通过抽象类来实现适配。

即：

一个接口，定义了很多方法，如果某一个类要实现这个接口，意味着要实现所有的方法。这个可能并不是我们想要的结果。如果我们只是想要其中一部分的接口约束，这个实现方式将使实现类变得臃肿。

于是，定义一个抽象类 来 以空方法【方法体什么都不写】来实现之前的接口。而真正的实现，再通过继承这个抽象类的方式来进行。



####  适配器模式的优缺点

**优点：**

​	 1、可以让任何两个没有关联的类一起运行。

​	 2、提高了类的复用。 

​	 3、增加了类的透明度。

**缺点：**

 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 

`揭晓答案`

   适配器模式，一般适用于已经上线了的项目，或是第三方接口与我们系统现有方法名不致的情况，并且短期不能重构去统一接口的情况下。是一种很没有办法的办法。

